{
  "task_fix_conductor_heartbeat": {
    "musician": "FileSystemMusician",
    "action": "write_file",
    "parameters": {
      "file_path": "C:\\syncphony\\conductor.py",
      "content": "# C:\\syncphony\\conductor.py\n\nimport json\nimport sys\nimport time\nimport multiprocessing\nimport asyncio\nimport os\nfrom datetime import datetime\nimport queue\n\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\nfrom telemetry import emit_telemetry_event, _telemetry_flusher_task\nfrom genome_data_cache import GenomeDataCache\n\n\ndef main(symphony_path, task_queues, reporting_queue, input_queue, log_queue):\n    \"\"\"\n    Main entry point for the Conductor Process.\n    Initializes its own asyncio event loop for GDC heartbeat and async operations.\n    \"\"\"\n    log_queue.put(\"[Conductor]: Process started, initializing asyncio loop.\")\n\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n\n    conductor = Conductor(symphony_path, task_queues, reporting_queue, input_queue, log_queue)\n\n    try:\n        loop.run_until_complete(conductor.run_conductor_async_loop())\n    finally:\n        loop.close()\n        log_queue.put(\"[Conductor]: Asyncio loop closed. Process shutting down.\")\n\n\nclass Conductor:\n    def __init__(self, symphony_path, task_queues, reporting_queue, input_queue, log_queue):\n        self.symphony_path = symphony_path\n        self.task_queues = task_queues\n        self.reporting_queue = reporting_queue\n        self.input_queue = input_queue\n        self.log_queue = log_queue\n        self.symphony_data = None\n        self.gdc = GenomeDataCache()\n        self.conductor_name = \"Conductor\"\n        self.current_symphony_id = None\n        # ADDED: State for the heartbeat task to track the last seen GDC root\n        self.last_heartbeat_gdc_root = None\n\n    async def run_conductor_async_loop(self):\n        \"\"\"The main asynchronous loop for the Conductor.\"\"\"\n        self.log_queue.put(\"[Conductor DEBUG]: Entering run_conductor_async_loop.\")\n\n        asyncio.create_task(_telemetry_flusher_task())\n        self.log_queue.put(\"[Conductor DEBUG]: Conductor's telemetry flusher task started (from run_conductor_async_loop).\")\n\n        asyncio.create_task(self._gdc_heartbeat_task())\n        self.log_queue.put(\"[Conductor DEBUG]: GDC heartbeat task started (from run_conductor_async_loop).\")\n\n        self.log_queue.put(\"[Conductor DEBUG]: Before symphony load call.\")\n        self.symphony_data = await asyncio.to_thread(self.load_symphony)\n        self.log_queue.put(\"[Conductor DEBUG]: After symphony load call. Symphony data is: \" + (\"None\" if self.symphony_data is None else \"Loaded\"))\n\n        if not self.symphony_data:\n            self.log_queue.put(\"[Conductor]: Halting due to error loading symphony.\")\n            await emit_telemetry_event(self.conductor_name, \"symphony_load_error\", \"task_error\",\n                                       {\"method\": \"load_symphony\", \"status\": \"failure\", \"path\": self.symphony_path,\n                                        \"error_message\": \"Symphony load failed.\", \"description\": \"Failed to load symphony file from disk.\"})\n            return\n\n        self.log_queue.put(\"[Conductor DEBUG]: Before first emit_telemetry_event for symphony_start.\")\n        await emit_telemetry_event(self.conductor_name, self.current_symphony_id, \"task_start\",\n                                   {\"method\": \"symphony_execution\", \"status\": \"in_progress\",\n                                    \"description\": f\"Starting Symphony: {self.symphony_path}\"})\n        self.log_queue.put(\"[Conductor DEBUG]: After first emit_telemetry_event for symphony_start.\")\n\n        self.log_queue.put(\"[Conductor DEBUG]: Before dispatch_and_wait call.\")\n        await self.dispatch_and_wait(self.symphony_data)\n        self.log_queue.put(\"[Conductor DEBUG]: After dispatch_and_wait call.\")\n\n\n        await emit_telemetry_event(self.conductor_name, self.current_symphony_id, \"task_complete\",\n                                   {\"method\": \"symphony_execution\", \"status\": \"success\",\n                                    \"description\": \"Symphony performance completed.\", \"result_summary\": \"All tasks processed according to plan.\"})\n        self.log_queue.put(\"[Conductor DEBUG]: After final emit_telemetry_event for symphony_complete.\")\n\n\n        self.log_queue.put(\"[Conductor]: Symphony performance finished. Conductor awaiting further commands or stop signal.\")\n        while True:\n            try:\n                command = await asyncio.to_thread(self.input_queue.get, timeout=1)\n                if command == 'STOP':\n                    self.log_queue.put(\"[Conductor]: Received STOP signal. Shutting down.\")\n                    break\n            except queue.Empty:\n                await asyncio.sleep(0.1)\n            except Exception as e:\n                self.log_queue.put(f\"[{self.conductor_name}]: Error reading input queue: {e}\")\n                await asyncio.sleep(1)\n\n    def load_symphony(self):\n        self.log_queue.put(f\"[{self.conductor_name}]: Loading Symphony from '{self.symphony_path}'...\")\n        try:\n            with open(self.symphony_path, 'r') as f:\n                symphony = json.load(f)\n            self.log_queue.put(f\"[{self.conductor_name}]: Symphony loaded successfully.\")\n\n            symphony_id = f\"symphony_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}_{os.urandom(4).hex()}\"\n            self.gdc.update_data(\"symphony_meta\", symphony_id, {\n                \"path\": self.symphony_path,\n                \"loaded_at\": datetime.utcnow().isoformat() + \"Z\",\n                \"total_tasks\": len(symphony),\n                \"status\": \"loaded\"\n            })\n            self.current_symphony_id = symphony_id\n\n            initial_task_states = {\n                task_id: {\"status\": \"pending\", \"dependencies\": task.get(\"dependencies\", []), \"musician\": task.get(\"musician\")}\n                for task_id, task in symphony.items()\n            }\n            for task_id, state in initial_task_states.items():\n                self.gdc.update_data(\"tasks\", task_id, state)\n\n            self.gdc.get_merkle_root()\n\n            return symphony\n        except FileNotFoundError:\n            self.log_queue.put(f\"[{self.conductor_name} ERROR]: Symphony file not found: '{self.symphony_path}'\")\n            return None\n        except json.JSONDecodeError as e:\n            self.log_queue.put(f\"[{self.conductor_name} ERROR]: Invalid JSON in Symphony file: {e}\")\n            return None\n        except Exception as e:\n            self.log_queue.put(f\"[{self.conductor_name} ERROR]: An unexpected error occurred loading symphony: {e}\")\n            return None\n\n    async def dispatch_and_wait(self, symphony):\n        self.log_queue.put(f\"[{self.conductor_name} DEBUG]: Entering dispatch_and_wait.\")\n\n        all_task_ids = set(symphony.keys())\n        completed_tasks = set()\n        dispatched_tasks = set()\n\n        def is_eligible(task_id_check):\n            deps = symphony[task_id_check].get('dependencies', [])\n            if not deps:\n                return task_id_check not in dispatched_tasks\n\n            for dep_id in deps:\n                dep_data = self.gdc.get_data(\"tasks\", dep_id)\n                if not dep_data or dep_data.get(\"status\") != \"completed\":\n                    return False\n            \n            return task_id_check not in dispatched_tasks\n\n\n        for task_id in all_task_ids:\n            if is_eligible(task_id):\n                musician_name = symphony[task_id].get('musician')\n                if musician_name and musician_name in self.task_queues:\n                    task_package = {'task_id': task_id, 'details': symphony[task_id]}\n                    await asyncio.to_thread(self.task_queues[musician_name].put, task_package)\n                    dispatched_tasks.add(task_id)\n\n                    self.gdc.update_data(\"tasks\", task_id, {\"status\": \"dispatched\", \"musician\": musician_name})\n\n                    self.log_queue.put(f\"[{self.conductor_name}]: Dispatched task '{task_id}' to '{musician_name}'.\")\n                else:\n                    self.log_queue.put(f\"[{self.conductor_name}]: WARNING! Skipping task '{task_id}' due to invalid or missing musician.\")\n                    self.gdc.update_data(\"tasks\", task_id, {\"status\": \"skipped\", \"reason\": \"invalid_musician\"})\n                    completed_tasks.add(task_id)\n\n        expected_total_tasks_to_resolve = len(all_task_ids)\n        \n        self.log_queue.put(f\"[{self.conductor_name}]: Monitoring {expected_total_tasks_to_resolve} tasks in total...\")\n\n        processed_tasks_for_loop_exit = completed_tasks.copy()\n        processed_tasks_for_loop_exit.update(dispatched_tasks)\n\n        while len(processed_tasks_for_loop_exit) < expected_total_tasks_to_resolve:\n            try:\n                report = await asyncio.to_thread(self.reporting_queue.get, timeout=0.1)\n                task_id = report.get('task_id')\n                status = report.get('status')\n                error = report.get('error')\n\n                task_data = self.gdc.get_data(\"tasks\", task_id)\n                if task_data:\n                    task_data[\"status\"] = status\n                    if error:\n                        task_data[\"error\"] = error\n                    self.gdc.update_data(\"tasks\", task_id, task_data)\n\n                if task_id not in processed_tasks_for_loop_exit:\n                    processed_tasks_for_loop_exit.add(task_id)\n                    completed_tasks.add(task_id)\n                    self.log_queue.put(f\"[{self.conductor_name}]: Received completion report for '{task_id}' (Status: {status}). ({len(processed_tasks_for_loop_exit)}/{expected_total_tasks_to_resolve} resolved)\")\n\n                    for tid in list(all_task_ids):\n                        if tid in processed_tasks_for_loop_exit or tid in dispatched_tasks:\n                            continue\n\n                        if is_eligible(tid):\n                            musician_name = symphony[tid].get('musician')\n                            if musician_name and musician_name in self.task_queues:\n                                task_package = {'task_id': tid, 'details': symphony[tid]}\n                                await asyncio.to_thread(self.task_queues[musician_name].put, task_package)\n                                dispatched_tasks.add(tid)\n                                processed_tasks_for_loop_exit.add(tid)\n                                \n                                self.gdc.update_data(\"tasks\", tid, {\"status\": \"dispatched\", \"musician\": musician_name})\n\n                                self.log_queue.put(f\"[{self.conductor_name}]: Task '{tid}' now eligible and dispatched to '{musician_name}' after dependencies met.\")\n                            else:\n                                self.log_queue.put(f\"[{self.conductor_name}]: WARNING! Skipping newly eligible task '{tid}' due to invalid or missing musician.\")\n                                self.gdc.update_data(\"tasks\", tid, {\"status\": \"skipped\", \"reason\": \"invalid_musician_dependency\"})\n                                completed_tasks.add(tid)\n                                processed_tasks_for_loop_exit.add(tid)\n\n\n                        else:\n                            deps = symphony[tid].get('dependencies', [])\n                            if deps:\n                                all_deps_resolved = True\n                                any_dep_failed = False\n                                for dep_id in deps:\n                                    dep_data = self.gdc.get_data(\"tasks\", dep_id)\n                                    if not dep_data or dep_data.get(\"status\") == \"pending\" or dep_data.get(\"status\") == \"dispatched\":\n                                        all_deps_resolved = False\n                                    elif dep_data.get(\"status\") == \"failed\":\n                                        any_dep_failed = True\n\n                                if all_deps_resolved and any_dep_failed:\n                                    self.log_queue.put(f\"[{self.conductor_name}]: Skipping task '{tid}' due to failed dependency/dependencies.\")\n                                    self.gdc.update_data(\"tasks\", tid, {\"status\": \"skipped\", \"reason\": \"failed_dependency\"})\n                                    completed_tasks.add(tid)\n                                    processed_tasks_for_loop_exit.add(tid)\n\n\n            except queue.Empty:\n                await asyncio.sleep(0.05)\n            except Exception as e:\n                self.log_queue.put(f\"[{self.conductor_name} ERROR]: Error processing report queue or dispatching: {e}\")\n                await asyncio.sleep(1)\n\n        pending_tasks_final = [tid for tid in all_task_ids if tid not in processed_tasks_for_loop_exit]\n        if pending_tasks_final:\n            self.log_queue.put(f\"[{self.conductor_name}]: Warning: {len(pending_tasks_final)} tasks remain pending (possible logic error, self-looping dependency, or unhandled scenario).\")\n            for tid in pending_tasks_final:\n                if self.gdc.get_data(\"tasks\", tid).get(\"status\") == \"pending\":\n                    self.gdc.update_data(\"tasks\", tid, {\"status\": \"stuck\", \"reason\": \"unresolved_dependencies_or_error_loop\"})\n        \n        self.log_queue.put(f\"[{self.conductor_name}]: All expected tasks processed. Performance finished.\")\n        self.gdc.get_merkle_root()\n\n    async def _gdc_heartbeat_task(self):\n        \"\"\"Periodically captures and logs GDC snapshots.\"\"\"\n        while True:\n            await asyncio.sleep(self.gdc.SNAPSHOT_INTERVAL_SECONDS)\n            current_root = self.gdc.get_merkle_root()\n\n            # CORRECTED LOGIC: The heartbeat now manages its own state\n            # to prevent false positives from a static GDC history.\n\n            # On the first run, initialize the root and skip the check.\n            if self.last_heartbeat_gdc_root is None:\n                self.last_heartbeat_gdc_root = current_root\n\n            self.log_queue.put(f\"[{self.conductor_name} GDC]: Snapshot taken. Merkle Root: {current_root}\")\n\n            await emit_telemetry_event(\n                self.conductor_name,\n                \"gdc_snapshot_system\",\n                \"gdc_snapshot\",\n                {\"merkle_root\": current_root, \"previous_root\": self.last_heartbeat_gdc_root,\n                 \"description\": \"GDC snapshot taken by heartbeat task.\"},\n                mask_sensitive=False\n            )\n\n            # Compare the current root to the last one this task saw.\n            if self.last_heartbeat_gdc_root != current_root:\n                self.log_queue.put(f\"[{self.conductor_name} GDC]: Detected change in GDC state!\")\n                await emit_telemetry_event(\n                    self.conductor_name,\n                    \"gdc_change_detected_alert\",\n                    \"task_error\",\n                    {\"method\": \"gdc_integrity_check\", \"status\": \"failure\", \"error_type\": \"GDCStateChange\",\n                     \"error_message\": \"GDC state changed between snapshots.\",\n                     \"description\": \"Alert: GDC state change detected.\"},\n                    mask_sensitive=False\n                )\n            \n            # Update the last known root for the next iteration.\n            self.last_heartbeat_gdc_root = current_root\n"
    }
  }
}